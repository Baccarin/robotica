function sysCall_init()
    -- do some initialization here
    RefPosition=sim.getObjectHandle("Reference")
    EndEffector=sim.getObjectHandle("EndEffector")
    
    Connector=sim.getObjectHandle("Connector")
    Proximity=sim.getObjectHandle("Proximity")
    
    Goal = sim.getObjectHandle("Goal")
    --Box = sim.getObjectHandle("Box")
    via = sim.getObjectHandle("via")
    
    --position_pick = sim.getObjectPosition(Box,-1)
    position_goal = sim.getObjectPosition(Goal,-1)
    position_via = sim.getObjectPosition(via,-1)
    
    --position_pick[2] = position_pick[2] - 0.1; --as length of the box is 0.2
    
    sim.setObjectPosition(RefPosition, -1, position_via)
    
    -------
    index = 0
    objects_to_move = {}
    while true do
    shape = sim.getObjects(index,sim.object_shape_type) --shape handle
    if (shape == -1) then -- -1 is ground
        break
    end
    
    --result1,parameter1 = sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable);
    -- if respondable then it return parameter1 = 1
    result2,parameter2 = sim.getObjectInt32Parameter(shape,sim.shapeintparam_static);
    -- if shape is static then it will return parameters2 = 1
    -- here the box is dynamic so it will return parameter2 = 0
    --result3,distance = sim.checkProximitySensor(Proximity,shape)
    --result3 = 1 if the shape is detected
    --if (result3==1) then
    --attachedShape = shape
    --sim.setObjectParent(attachedShape,Connector,true)
    --	sim.setObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)
    --break
    --end
    if (parameter2 == 0) then
        table.insert(objects_to_move,shape)
    end
    
    index =index+1
    end
    --print(objects_to_move)
    -------
    
    state_start = 0;
    state_via2pick = 1;
    state_pick = 2;
    state_pick2via = 3;
    state_via2goal = 4;
    state_goal = 5;
    state_goal2via = 6;
    state_stop = 7;
    
    state = state_start; --initializing the FSM
    t_f = 1;
    box_no = 1;
    
end

function sysCall_actuation()
    -- put your actuation code here
    
    t= sim.getSimulationTime()
    
    
    position_pick = sim.getObjectPosition(objects_to_move[box_no],-1)
    position_pick[2] = position_pick[2] - 0.1;
    
    n = table.getn(objects_to_move)
    state = singlePickandPlace()
    if (state == state_stop and box_no<n) then
        state = state_start
        box_no = box_no+1
        t_f = sim.getSimulationTime()
    end
    
    --[[t1 = 1;
    t2 = 3
    t3 = 5
    if (t>=t1 and t<t2) then -- transitions (arrows)
    --sim.setObjectPosition(RefPosition, -1, position_pick) --moves the Reference to the position pick
    position_i = position_via --action (bubbles/circles)
    position_f = position_pick
    t_i = t1;
    t_f = t2;
    moveIK(position_i,position_f,t_i,t_f)
    elseif (t>=t2 and t<t3) then
    --sim.setObjectPosition(RefPosition, -1, position_pick) --moves the Reference to the position pick
    position_i = position_pick
    position_f = position_via
    t_i = t2;
    t_f = t3;
    moveIK(position_i,position_f,t_i,t_f)
    
    ]]--
    
    --[[--- make the end-effector grasp the object ---
    shapeAttached = graspObject()
    elseif (t>=6 and t<9) then
    sim.setObjectPosition(RefPosition, -1, position_via)
    elseif (t>=9 and t<11) then
    sim.setObjectPosition(RefPosition, -1, position_goal)
    elseif (t>=11 and t<12) then
    --- make the end-effector release the object ---
    releaseObject(shapeAttached)
    elseif (t>=12 and t<15) then
    sim.setObjectPosition(RefPosition, -1, position_via)]]--
    --end
end

function sysCall_sensing()
    -- put your sensing code here
end

function sysCall_cleanup()
    -- do some clean-up here
end

function singlePickandPlace()

--- transitions (arrows) ---
duration = 2;

if (state==state_start and t>=t_f) then --set transition and initialize the state
    state = state_via2pick
   position_i = position_via;
    position_f = position_pick;
    t_i = t_f;
    t_f = t_i+duration;
elseif (state==state_via2pick and t>=t_f) then --set transition and initialize the state
    state = state_pick
elseif (state==state_pick and t>=t_f) then --set transition and initialize the state
    state = state_pick2via
   position_i = position_pick;
  position_f = position_via;
    t_i = t_f;
    t_f = t_i+duration;
elseif (state==state_pick2via and t>=t_f) then --set transition and initialize the state
    state = state_via2goal
   position_i = position_via;
  position_f = position_goal;
    t_i = t_f;
    t_f = t_i+duration;
elseif (state==state_via2goal and t>=t_f) then --set transition and initialize the state
    state = state_release
elseif (state==state_release and t>=t_f) then   
    state = state_goal2via
    position_i = position_goal;
    position_f = position_via;
    t_i = t_f;
    t_f = t_i+duration;
elseif (state==state_goal2via and t>=t_f) then --set transition and initialize the state
    state = state_stop
end



-- actions (circles) ---
if (state==state_via2pick) 
  or (state == state_pick2via) 
  or (state == state_via2goal) 
  or (state == state_goal2via) then
    moveIK(position_i,position_f,t_i,t_f)
end

if (state==state_pick) then
    shapeAttached = graspObject()
end

if (state==state_release) then
    releaseObject(shapeAttached)
end

return state

end



function moveIK(position_i,position_f,t_i,t_f)
x_i = position_i[1];
y_i = position_i[2];
z_i = position_i[3];

x_f = position_f[1];
y_f = position_f[2];
z_f = position_f[3];

dt = t_f - t_i;
dx = x_f - x_i
vx = dx/dt;
dy = y_f - y_i
vy = dy/dt;
dz = z_f - z_i
vz = dz/dt;

x = x_i + vx*(t-t_i)
y = y_i + vy*(t-t_i)
z = z_i + vz*(t-t_i)

position_ref = {x,y,z}
sim.setObjectPosition(RefPosition, -1, position_ref)


end


-- See the user manual or the available code snippets for additional callback functions and details
function releaseObject(shapeAttached)
    sim.setObjectParent(shapeAttached,-1,true) -- -1 is the ground
    --	sim.setObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)
    

end

function graspObject()

index = 0
   while true do
    shape = sim.getObjects(index,sim.object_shape_type) --shape handle
    if (shape == -1) then -- -1 is ground
        break
    end
    
    result1,parameter1 = sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable);
    -- if respondable then it return parameter1 = 1
    result2,parameter2 = sim.getObjectInt32Parameter(shape,sim.shapeintparam_static);
    -- if shape is static then it will return parameters2 = 1
    -- here the box is dynamic so it will return parameter2 = 0
    result3,distance = sim.checkProximitySensor(Proximity,shape)
    --result3 = 1 if the shape is detected
    if (result3==1) then
    attachedShape = shape
    sim.setObjectParent(attachedShape,Connector,true)
    --	sim.setObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)
    break
    end
    index =index+1
    end
    return attachedShape

end